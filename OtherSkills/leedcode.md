# LeedCode 梳理

## 字符串类
<details>
<summary> 1. 验证回文串 (easy)（https://leetcode-cn.com/problems/valid-palindrome/） </summary> 
</details>

<details>
<summary> 2. 分割回文串 (medium)（https://leetcode-cn.com/problems/palindrome-partitioning/） </summary> 
</details>

<details>
<summary> 3. 单词拆分 (medium)（https://leetcode-cn.com/problems/word-break/） </summary> 
</details>

<details>
<summary> 4. 单词拆分 II (hard)（https://leetcode-cn.com/problems/word-break-ii/） </summary> 
</details>

<details>
<summary> 5. 单词搜索 II (hard)（https://leetcode-cn.com/problems/word-search-ii/） </summary> 
</details>

<details>
<summary> 6. 实现 Trie (前缀树) (medium)（https://leetcode-cn.com/problems/implement-trie-prefix-tree/） </summary> 
</details>



## 数组类
<details>
<summary> 1. 最大子段和 (easy)（https://leetcode-cn.com/problems/maximum-subarray/） </summary> 
</details>
<details>
<summary> 2. 最大子矩阵 (hard)（https://leetcode-cn.com/problems/max-submatrix-lcci/） </summary> 
</details>

## 链表类

<details>
<summary> 1. 反转链表 （easy）（https://leetcode-cn.com/problems/reverse-linked-list/） </summary> 
</details>

<details>
<summary> 2. 链表中倒数第k个节点 (easy)（https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/） </summary> 
</details>

<details>
<summary> 3. 环形链表 (easy)（https://leetcode-cn.com/problems/linked-list-cycle/） </summary> 
</details>

<details>
<summary> 4. 相交链表 (easy)（https://leetcode-cn.com/problems/intersection-of-two-linked-lists/） </summary> 
</details>

<details>
<summary> 5. 回文链表 (easy)（https://leetcode-cn.com/problems/palindrome-linked-list/） </summary> 
</details>

<details>
<summary> 6. 链表排序 (medium)（https://leetcode-cn.com/problems/sort-list/） </summary> 
</details>

<details>
<summary> 7. 删除链表中的节点 (easy)（https://leetcode-cn.com/problems/delete-node-in-a-linked-list/） </summary> 
</details>

<details>
<summary> 8. 奇偶链表 (medium)（https://leetcode-cn.com/problems/odd-even-linked-list/） </summary> 
</details>

<details>
<summary> 9. 复杂链表的复制 (medium)（https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/） </summary> 
</details>

<details>
<summary> 10. 设计链表 (medium)（https://leetcode-cn.com/problems/design-linked-list/） </summary> 
</details>


<details>
<summary> 11. 分隔链表 (medium)（https://leetcode-cn.com/problems/split-linked-list-in-parts/） </summary> 
</details>

<details>
<summary> 12. 分隔链表 (medium)（https://leetcode-cn.com/problems/partition-list/） </summary> 
</details>

<details>
<summary> 13. 链表求和 (medium)（https://leetcode-cn.com/problems/sum-lists-lcci/） </summary> 
</details>

<details>
<summary> 14. 重排链表 (medium)（https://leetcode-cn.com/problems/reorder-list/） </summary> 
</details>

<details>
<summary> 15. 旋转链表 (medium)（https://leetcode-cn.com/problems/rotate-list/） </summary> 
</details>

<details>
<summary> 16. 环形链表 II (medium)（https://leetcode-cn.com/problems/linked-list-cycle-ii/） </summary> 
</details>

<details>
<summary> 17. 反转链表 II (medium)（https://leetcode-cn.com/problems/reverse-linked-list-ii/） </summary> 
</details>

<details>
<summary> 18. 特定深度节点链表 (medium)（https://leetcode-cn.com/problems/list-of-depth-lcci/） </summary> 
</details>

<details>
<summary> 19. 合并两个有序链表 (easy)（https://leetcode-cn.com/problems/merge-two-sorted-lists/） </summary> 
</details>

<details>
<summary> 20. 合并K个升序链表 (hard)（https://leetcode-cn.com/problems/merge-k-sorted-lists/） </summary> 
</details>

<details>
<summary> 21. 对链表进行插入排序 (medium)（https://leetcode-cn.com/problems/insertion-sort-list/） </summary> 
</details>

<details>
<summary> 22. 链表的中间结点 (easy)（https://leetcode-cn.com/problems/middle-of-the-linked-list/） </summary> 
</details>

<details>
<summary> 23. K 个一组翻转链表 (hard)（https://leetcode-cn.com/problems/reverse-nodes-in-k-group/） </summary> 
</details>

<details>
<summary> 24. 扁平化多级双向链表 (medium)（https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/） </summary> 
</details>

<details>
<summary> 25. 从尾到头打印链表 (easy)（https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/） </summary> 
</details>

## 树类

<details>
<summary> 1. 天际线问题 ()（https://leetcode-cn.com/problems/the-skyline-problem/） </summary> 
</details>


### 二叉树类
<details>
<summary> 1. 二叉树的最近公共祖先 (medium)（https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/） </summary> 
</details>

<details>
<summary> 2. 平衡二叉树 (easy)（https://leetcode-cn.com/problems/balanced-binary-tree/） </summary> 
</details>

<details>
<summary> 3. 二叉搜索树的第k大节点  (easy)（https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/） </summary> 
</details>

<details>
<summary> 4. 重建二叉树 (medium)（https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/） </summary> 
</details>

<details>
<summary> 5. 二叉树的深度  (easy)（https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/） </summary> 
</details>

<details>
<summary> 6. 二叉树的序列化与反序列化  (hard)（https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/） </summary> 
</details>

<details>
<summary> 7. 二叉搜索树与双向链表 (medium)（https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/） </summary> 
</details>

<details>
<!--summary> x.  ()（） </summary--> 
</details>

## 图类
<details>
<summary> 1. 岛屿数量 (medium)（https://leetcode-cn.com/problems/number-of-islands/） </summary> 
</details>

<details>
<summary> 2. 课程表 (medium)（https://leetcode-cn.com/problems/course-schedule/） </summary> 
</details>

<details>
<summary> 3. 课程表 II (medium)（https://leetcode-cn.com/problems/course-schedule-ii/） </summary> 
</details>

<details>
<summary> 4. 单词接龙 (medium)（https://leetcode-cn.com/problems/word-ladder/） </summary> 
</details>

<details>
<summary> 5. 判断二分图 (medium)（https://leetcode-cn.com/problems/is-graph-bipartite/） </summary> 
</details>

<details>
<summary> 6. 项目管理 (hard)（https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/） </summary> 
</details>

<details>
<summary> 7. 正方形数组的数目 (hard)（https://leetcode-cn.com/problems/number-of-squareful-arrays/） </summary> 
</details>

<details>
<summary> 8. 找到最终的安全状态 (medium)（https://leetcode-cn.com/problems/find-eventual-safe-states/ </summary> 
</details>

<details>
<summary> 9. 概率最大的路径 (medium)（https://leetcode-cn.com/problems/path-with-maximum-probability/） </summary> 
</details>

<details>
<summary> 10. 不邻接植花 (easy)（https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/） </summary> 
</details>


## 数学类
<details>
<!--summary> x.  ()（） </summary--> 
</details>


## 数据结构类

<details>
<summary> 1. 稀疏相似度 (倒排索引) （https://leetcode-cn.com/problems/sparse-similarity-lcci/） </summary> 

题解：
```bash
class Solution {
public:
    vector<string> computeSimilarities(vector<vector<int>>& docs) {
        vector<string> res;
        unordered_map<int, vector<int> > elem2doc;
        for (size_t doc_id = 0; doc_id < docs.size(); ++doc_id) {
            for (size_t elem_id = 0; elem_id < docs[doc_id].size(); ++elem_id) {
                elem2doc[docs[doc_id][elem_id]].push_back(doc_id);
            }
        }
        
        unordered_map<int, unordered_map<int, size_t> > doc2doc2freq;
        for (auto iter = elem2doc.begin(); iter != elem2doc.end(); ++iter) {
            for (size_t id = 0; id < iter->second.size(); ++id) {
                for (size_t k = id+1; k < iter->second.size(); ++k) {
                    doc2doc2freq[iter->second[id]][iter->second[k]]++;
                }
            }
        }

        for (auto iter = doc2doc2freq.begin(); iter != doc2doc2freq.end(); ++iter) {
            for (auto iter2 = iter->second.begin(); iter2 != iter->second.end(); ++iter2) {
                double similarity = double(iter2->second) / double(docs[iter->first].size() + docs[iter2->first].size() - iter2->second);
                if (similarity >= 0.000005f) {
                    char buffer[256];
                    int n = snprintf(buffer, 256, "%lu,%lu: %.4f", iter->first, iter2->first, similarity + 1e-9);
                    if (0 < n && n < 256) {
                        buffer[n] = '\0';
                        res.push_back(buffer);
                    }
                }
            }
        }
        return res;
    }
};
``` 

超时题解（O(n^2*m)）：
```c++
class Solution {
public:
    string compare2DocSimilarity(vector<int>& short_doc, size_t short_id, vector<int>& long_doc, size_t long_id) {
        if (short_doc.size() > long_doc.size()) return compare2DocSimilarity(long_doc, long_id, short_doc, short_id);
        string res("");
        if (short_doc.empty()) return res;
        unordered_set<int> short_set;
        for (size_t id = 0; id < short_doc.size(); ++id) short_set.insert(short_doc[id]);
        size_t intersection_num = 0;
        size_t unionsection_num = short_set.size();
        for (size_t id = 0; id < long_doc.size(); ++id) {
            if (short_set.find(long_doc[id]) != short_set.end()) {
                ++intersection_num;
            } else {
                ++unionsection_num;
            }
        }
        double similarity = double(intersection_num) / double(unionsection_num);
        if (similarity < 0.00005f) return res;
        char buffer[256];
        size_t min_id = min(short_id, long_id);
        size_t max_id = max(short_id, long_id);
        int n = snprintf(buffer, 256, "%lu,%lu: %.4f", min_id, max_id, similarity+1e-9);
        if (0 < n && n < 256) {
            buffer[n] = '\0';
        }
        return buffer;
    }

    vector<string> computeSimilarities(vector<vector<int>>& docs) {
        vector<string> res;
        for (size_t m = 0; m < docs.size(); ++m) {
            for (size_t n = m+1; n < docs.size(); ++n) {
                string cmp_str = compare2DocSimilarity(docs[m], m, docs[n], n);
                if (!cmp_str.empty()) {
                    res.push_back(cmp_str);
                }
            }
        }
        return res;

    }
};
```

</details>



### 栈


### 队列


### 堆




-----------
# 附录
-----------
## 算法解题思想 
算法思想：枚举，模拟，递推，递归，分治，动归，贪心和回溯（试探，万能解，一般需要挖掘约束条件做剪枝来提升效率）。
### 分治
### 动态规划

### 贪心
### 回溯
### 分支界限法
